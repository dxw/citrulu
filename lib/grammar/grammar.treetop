grammar TesterGrammar
  rule test_file
    comment* space test_group+ space {
      def process
        elements[2].elements.collect{|e| e.process}
      end
    }
  end

  rule test_group
    comment* page_clause comment* single_assertion comment* test_line* comment* {
      def process
        results = {
          :page => page_clause.process,
          :tests => elements[5].elements.collect{|e| e.process}
        }

        single_assertions = single_assertion.process

        results[:page][:first] = single_assertions[:first]
        results[:page][:finally] = single_assertions[:finally]

        # TODO: only add if there isn't one

        assertions = results[:tests].collect{|x| x[:assertion]}.uniq
        if !assertions.include?(:response_code_be) && !assertions.include?(:response_code_not_be)
          results[:tests].insert(0, {
            :assertion => :response_code_be,
            :value => '200',
            :original_line => 'Response code should be 200'
          })
        end

        results
      end
    }
  end

  rule single_assertion
    first_clause? comment* finally_clause? comment* {
      def process
        if elements
          results = {}

          results[:first] = elements[0].url.text_value.strip if !elements[0].empty?
          results[:finally] = elements[2].url.text_value.strip if !elements[2].empty?

          results
        end
      end
    }
  end

  rule on_clause
    space "On" space url {
      def process
      {
        :method => :get,
        :data => '',
        :url => url.text_value.strip
      }
      end
    }
  end

  rule when_clause
    space "When I" (method_data / method) space url {
      def process
        elements[2].process.merge({
          :url => url.text_value.strip
        })
      end
    }
  end

  rule method_data
     space ("put" / "post") space data space "to" {
       def process
         {
           :method => elements[1].text_value.strip.to_sym,
           :data => data.process
         }
       end
     }
  end

  rule method
     space ("head" / "get" / "delete") {
       def process
         {:method => text_value.strip.to_sym}
       end
     }
  end

  rule page_clause
    so_clause? comment* (on_clause / when_clause) comment* newline {
      def process
        elements[2].process.merge({:so => elements[0].text_value.strip})
      end
    }
  end

  rule so_clause
    space "So" required_value newline
  end

  rule first_clause
    space "First, fetch " url 
  end

  rule finally_clause
    space "Finally, fetch " url comment* newline
  end

  rule test_line
    comment* space test comment* newline {
      def process
        test.process
      end
    }
  end
 
  rule test
    (complex_assertion / simple_assertion) space parameter {
      def process
        hash = elements[0].process

        hash[:original_line] = text_value.strip

        if parameter.text_value.match(/^:/)
          if parameter.text_value.match(/^::/)
            hash[:value] = parameter.text_value.gsub(/^::/, ':').strip
          else
            hash[:name] = parameter.text_value.strip
          end
        else
          hash[:value] = parameter.text_value.strip

          if matches = hash[:value][0] == '"' && hash[:value][-1] == '"'
            hash[:value] = hash[:value][1..-2]
          end

          if matches = hash[:value][0] == '/' && hash[:value][-1] == '/'
            hash[:value] = Regexp.new(hash[:value][1..-2])
          end
        end

        hash
      end
    }
  end

  rule simple_assertion
    ("Source should contain" / "Source should not contain" / "I should see" / "I should not see" / "Headers should include" / "Headers should not include" / "Response code should be" / "Response code should not be" ) {
      def process
      {:assertion => text_value.to_test_sym}
      end
    }
  end

  rule complex_assertion
    "Header " identifier space ("should contain" / "should not contain") {
      def process 
        {
          :header => identifier.text_value.strip,
          :assertion => elements[4].text_value.to_test_sym
        }
      end
    }
  end

  rule parameter
    (escaped_value / name / regex / value)
  end

  rule newline
    [\r\n]+ 
  end
  
  rule value
    [^\n]*
  end

  rule required_value
    [^\n]+
  end

  rule data
    '"' [^"]+ '"' {
      def process
        text_value[1..-2]
      end
    }
  end

  rule regex
    '/' [^\/]+ '/'
  end

  rule comment
    space '#' [^\n]*
  end

  rule escaped_value
    '::' [^\n]*
  end

  rule name
    ':' identifier
  end

  rule identifier
    [a-zA-Z0-9_-]+
  end

  rule url
    ('http://' / 'https://') ([a-zA-Z0-9]+ [^\n\s]+)
  end

  rule space
    [\s\t]*  
  end
end

